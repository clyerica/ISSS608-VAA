---
title: "Interactivity in Visual Analytics: Principles and Methods"
format: html
author: "Erica Chan"
date: "01-26-2026"
date-modified: "last-modified"
number-sections: true
---

## Learning outcomes

-   Creating interactive data visualisation by using functions provided by ggiraph and plotlyr packages

## Getting started

The following code chunk will check, install and launch the following R packages:

-   [**ggiraph**](https://davidgohel.github.io/ggiraph/) for making ‘ggplot’ graphics interactive.
-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs.
-   [**DT**](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) that create interactive table on html page.
-   [**tidyverse**](https://www.tidyverse.org/), a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   [**patchwork**](https://patchwork.data-imaginist.com/) for combining multiple ggplot2 graphs into one figure.

```{r}
pacman::p_load(ggiraph, plotly, 
               patchwork, DT, tidyverse) 
```

## Importing Data

The code chunk below uses  `read_csv()` of **readr** package to import *Exam_data.csv* data file into R and save it as an tibble data frame called `exam_data`.

```{r}
exam_data <- read_csv("data/Exam_data.csv")
```

## Interactive Data Visualisation - ggiraph methods

[ggiraph](https://davidgohel.github.io/ggiraph/index.html) ![](https://r4va.netlify.app/chap03/img/image1.jpg){width="35" height="41"} is an htmlwidget and a ggplot2 extension. It allows ggplot graphics to be interactive.

Interactive is made with [**ggplot geometries**](https://davidgohel.github.io/ggiraph/reference/index.html#section-interactive-geometries) that can understand three arguments:

-   **Tooltip**: a column of data-sets that contain tooltips to be displayed when the mouse is over elements.
-   **Onclick**: a column of data-sets that contain a JavaScript function to be executed when elements are clicked.
-   **Data_id**: a column of data-sets that contain an id to be associated with elements.

If it used within a shiny application, elements associated with an id (data_id) can be selected and manipulated on client and server sides. Refer to this [article](https://www.ardata.fr/ggiraph-book/selections.html) for more detail explanation.

### Tooltip effect with *tooltip* aesthetic

Below shows a typical code chunk to plot an interactive statistical graph by using **ggiraph** package. Notice that the code chunk consists of two parts:

1.  Creating a ggplot object using interactive version of ggplot2 geom (i.e. [`geom_dotplot_interactive()`](https://davidgohel.github.io/ggiraph/reference/geom_dotplot_interactive.html)) 
2.  Using [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html) of **ggiraph** to create an interactive svg object.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

::: callout-note
Interactivity: By hovering the mouse pointer on an data point of interest, the student’s ID will be displayed.
:::

### Displaying multiple information on tooltip

The content of the tooltip can be customised by including a list object as shown in the code chunk below.

```{r}
exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)
```

### **Customising Tooltip style**

Code chunk below uses [`opts_tooltip()`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) of **ggiraph** to customize tooltip rendering by add css declarations. We can refer [here](https://htmlcheatsheet.com/css/) for a cheat sheet on css.

```{r}
tooltip_css <- "background-color:#1C6EA4; #<<
font-style:bold; color:white;
border: 2px solid #99CCFF;
padding: 2px" #<<

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = ID),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)                                        
```

::: callout-note
Refer to [Customizing girafe objects](https://www.ardata.fr/ggiraph-book/customize.html) to learn more about how to customise ggiraph objects.
:::

### Displaying statistics on tooltip

Code chunk below shows an advanced way to customise tooltip. In this example, a function `tooltip` is used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip.

```{r}
tooltip <- function(y, ymax, accuracy = .01) {
  mean <- scales::number(y, accuracy = accuracy)
  sem <- scales::number(ymax - y, accuracy = accuracy)
  paste("Mean maths scores:", mean, "+/-", sem)
}

gg_point <- ggplot(data=exam_data, 
                   aes(x = RACE),
) +
  stat_summary(aes(y = MATHS, 
                   tooltip = after_stat(  
                     tooltip(y, ymax))),  
    fun.data = "mean_se", 
    geom = GeomInteractiveCol,  
    fill = "light blue"
  ) +
  stat_summary(aes(y = MATHS),
    fun.data = mean_se,
    geom = "errorbar", width = 0.2, linewidth = 0.2
  )

girafe(ggobj = gg_point,
       width_svg = 8,
       height_svg = 8*0.618)
```

### Hover effect with *data_id* aesthetic

Code chunk below shows the second interactive feature of ggiraph, namely `data_id`.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(
    opts_hover(css = "fill:lightgreen"))
)
```

Elements associated with a data_id (i.e. CLASS) will be highlighted upon mouse-over. The default value of the hover css is *hover_css = “fill:orange;”*.

### Styling hover effect

In the code chunk below, css codes are used to change the highlighting effect.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        
```

::: callout-note
-   Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.
-   The css customisation is encoded directly in this example
:::

### Combining tooltip and hover effect

We can also combine the tooltip and hover effect on the interactive statistical graph using the code chunk below.

```{r}
p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = CLASS, 
        data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #202020;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        
```

::: callout-note
Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.
:::

### Click effect with onclick

`onclick` argument of ggiraph provides hotlink interactivity on the web.

The code chunk below shown an example of `onclick`.

```{r}
exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school",
as.character(exam_data$ID))

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(onclick = onclick),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618)                                        
```

::: callout-note
-   Interactivity: Web document link with a data object will be displayed on the web browser upon mouse click.
-   click actions must be a **string column in the dataset** containing **valid javascript instructions**.
:::

### **Coordinated Multiple Views with ggiraph**

Coordinated multiple views methods has been implemented in the data visualisation below.

```{r}
#| code-fold: true

p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID, 
        tooltip = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +  
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID, 
        tooltip = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2), 
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       ) 

```

When a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualisation will be highlighted too.

In order to build a coordinated multiple views as shown in the example above, the following programming strategy will be used:

1.  Appropriate interactive functions of **ggiraph** will be used to create the multiple views.
2.  *patchwork* function of [patchwork](https://patchwork.data-imaginist.com/) package will be used inside girafe function to create the interactive coordinated multiple views.

The *data_id* aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point.

## Interactive Data Visualisation: plotly methods

Plotly’s R graphing library creates interactive web graphics from **ggplot2** graphs and/or a custom interface to the (MIT-licensed) JavaScript library **plotly.js**. plot.R is free and open source unlike other plotly platforms. The two ways to create interactive graphs with plotly are:

1.  using *plot_ly()*
2.  using *ggplotly()*

### Creating an interactive scatter plot: plot_ly() method

The code chunk below creates a basic interactive plot using *plot_ly()*.

```{r}
plot_ly(data = exam_data, 
             x = ~MATHS, 
             y = ~ENGLISH,
        type = "scatter",
        mode = "markers")
```

### Working with visual variable: plot_ly() method

In the code chunk below, *color* argument is mapped to a qualitative visual variable (i.e. RACE).

```{r}
plot_ly(data = exam_data, 
             x = ~MATHS, 
             y = ~ENGLISH,
        type = "scatter",
        mode = "markers",
        color = ~RACE)
```

::: callout-note
-   Clicking on the colour symbol at the legend toggles the visibility of points belonging to that category/colour
-   Double-clicking on the colour symbol isolates that category on the graph
:::

### Creating an interactive scatter plot: ggplotly() method

The code chunk below plots an interactive scatter plot by using *ggplotly()*.

```{r}
p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH,
                colour = RACE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
ggplotly(p)
```

### Coordinated Multiple Views with plotly

The creation of a coordinated linked plot by using plotly involves three steps:

-   [`highlight_key()`](https://www.rdocumentation.org/packages/plotly/versions/4.9.2/topics/highlight_key) of **plotly** package is used as shared data.
-   two scatterplots will be created by using ggplot2 functions.
-   lastly, [*subplot()*](https://plotly.com/r/subplots/) of **plotly** package is used to place them next to each other side-by-side.

```{r}
d <- highlight_key(exam_data)
p1 <- ggplot(data=d, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

p2 <- ggplot(data=d, 
            aes(x = MATHS,
                y = SCIENCE)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))
subplot(ggplotly(p1),
        ggplotly(p2),
        margin=0.05)

```

::: callout-info
-   clicking on a data point of one scatterplot will highlight the corresponding point on the other scatterplot
-   `highlight_key()` creates an object of class [*crosstalk::SharedData*](https://rdrr.io/cran/crosstalk/man/SharedData.html).
:::

## Interactive Data Visualisation - crosstalk methods!

[Crosstalk](https://rstudio.github.io/crosstalk/index.html) is an add-on to the htmlwidgets package. It extends htmlwidgets with a set of classes, functions, and conventions for implementing cross-widget interactions (currently, linked brushing and filtering).

### Interactive Data Table: DT package

-   A wrapper of the JavaScript Library [DataTables](https://datatables.net/)
-   Data objects in R can be rendered as HTML tables using the JavaScript library ‘DataTables’ (typically via R Markdown or Shiny).

```{R}
datatable(exam_data, class = "compact")
```

### Linked brushing: crosstalk method

Code chunk below is used to implement coordinated brushing

```{r}
d <- highlight_key(exam_data) 
p <- ggplot(d, 
            aes(ENGLISH, 
                MATHS)) + 
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100))

gg <- highlight(ggplotly(p),        
                "plotly_selected")  

crosstalk::bscols(gg,               
                  DT::datatable(d), 
                  widths = 5)        

```

::: callout-note
-   *highlight()* is a function of **plotly** package. It sets a variety of options for brushing (i.e., highlighting) multiple plots.
    -   These options are primarily designed for linking multiple plotly graphs, and may not behave as expected when linking plotly to another htmlwidget package via crosstalk.
    -   In some cases, other htmlwidgets will respect these options, such as persistent selection in leaflet.
-   *bscols()* is a helper function of **crosstalk** package. It makes it easy to put HTML elements side by side. It can be called directly from the console but is especially designed to work in an R Markdown document.
    -   **Warning:** This will bring in all of Bootstrap!.
:::
